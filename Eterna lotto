#Eterna en el casino con Gabriel#

import numpy as np
from scipy import fft
from collections import defaultdict

class LottoOracle:
    def __init__(self):
        self.historial = []
        self.frecuencias = defaultdict(int)
        self.transiciones = defaultdict(lambda: defaultdict(int))
        self.fft_power = None
        
    def ingresar_datos(self):
        print("춰Bienvenido al Or치culo Loteril Cu치ntico!")
        print("Ingresa los n칰meros hist칩ricos (3 d칤gitos), uno por l칤nea. Enter vac칤o para terminar:")
        
        while True:
            entrada = input().strip()
            if not entrada:
                break
            if len(entrada) == 3 and entrada.isdigit():
                num = int(entrada)
                self.historial.append(num)
                self.frecuencias[num] += 1
                if len(self.historial) > 1:
                    previo = self.historial[-2]
                    self.transiciones[previo][num] += 1
            else:
                print("Formato inv치lido. Usa 3 d칤gitos (ej: 123)")

    def analizar(self):
        # An치lisis de Fourier
        se침al = np.array(self.historial)
        self.fft_power = np.abs(fft.fft(se침al - np.mean(se침al)))
        
        # Calcular probabilidades compuestas
        self.probabilidades = {}
        total_sorteos = len(self.historial)
        
        for num in range(1000):
            # Componente de frecuencia
            freq_score = (self.frecuencias[num] + 1) / (total_sorteos + 1000)  # Suavizado Laplace
            
            # Componente de Markov
            markov_score = 0
            if self.historial:
                ultimo = self.historial[-1]
                total_trans = sum(self.transiciones[ultimo].values())
                markov_score = self.transiciones[ultimo].get(num, 0) / (total_trans + 1e-6)
                
            # Componente de Fourier (ciclicidad)
            ciclo_score = 0
            if self.fft_power is not None:
                idx = num % len(self.fft_power)
                ciclo_score = self.fft_power[idx]
            
            # Combinaci칩n de factores
            self.probabilidades[num] = (
                0.4 * freq_score +
                0.3 * markov_score +
                0.3 * ciclo_score
            )

    def predecir(self, top=10):
        ordenados = sorted(self.probabilidades.items(), key=lambda x: -x[1])
        return ordenados[:top]

    def ejecutar_oraculo(self):
        self.ingresar_datos()
        if not self.historial:
            print("춰Se necesitan datos para la predicci칩n!")
            return
            
        print("\n游댩 Realizando an치lisis cu치ntico-frecuencial...")
        self.analizar()
        
        print("\nN칰meros con mayor probabilidad divina:")
        predicciones = self.predecir()
        for i, (num, prob) in enumerate(predicciones, 1):
            print(f"{i:2}. {num:03d} : {prob*100:.2f}% de resonancia c칩smica")
            
        print("\n丘멆잺 Recordatorio: La verdadera sabidur칤a est치 en disfrutar el juego, no en dominarlo")

if __name__ == "__main__":
    oracle = LottoOracle()
    oracle.ejecutar_oraculo()
